<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>NEON BERZERK</title>
<style>
html,body{margin:0;height:100%;background:#03040c;overflow:hidden}
canvas{display:block;width:100vw;height:100vh}
#hud{
  position:fixed;left:12px;top:10px;
  color:#c7f9ff;font-size:14px;
  text-shadow:0 0 14px rgba(0,255,255,.7)
}
#centerMsg{
  position:fixed;left:50%;top:50%;
  transform:translate(-50%,-50%);
  font-size:38px;
  color:#ff4df0;
  text-shadow:0 0 30px rgba(255,0,255,1);
  pointer-events:none;
  display:none;
  text-align:center;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="hud"></div>
<div id="centerMsg"></div>

<script>
(() => {

/* ================= SETUP ================= */
const canvas=document.getElementById("c");
const ctx=canvas.getContext("2d",{alpha:false});
function resize(){
  const dpr=Math.min(2,devicePixelRatio||1);
  canvas.width=innerWidth*dpr;
  canvas.height=innerHeight*dpr;
  ctx.setTransform(dpr,0,0,dpr,0,0);
}
addEventListener("resize",resize); resize();

const ROOM_W=960, ROOM_H=600;
const WALL=14, GRID=96, GAP=96;
const PLAYER_SPEED=240, ENEMY_SPEED=55;
const BULLET_SPEED=620, ENEMY_BULLET_SPEED=420;
const R=14;

let lives=3, gameOver=false;
const effects=[];

const keys=new Set();

/* ================= UI ================= */
const msgEl=document.getElementById("centerMsg");
function showMessage(html){
  msgEl.innerHTML=html;
  msgEl.style.display="block";
}
function hideMessage(){
  msgEl.style.display="none";
  msgEl.innerHTML="";
}

onkeydown=e=>{
  if(gameOver){
    keys.clear();
    restartGame();
    return;
  }
  keys.add(e.code);
};
onkeyup=e=>keys.delete(e.code);

const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
const rand=(a,b)=>a+Math.random()*(b-a);
const now=()=>performance.now()/1000;

/* ================= GEOMETRY ================= */
function circleRect(cx,cy,r,w){
  const nx=clamp(cx,w.x,w.x+w.w);
  const ny=clamp(cy,w.y,w.y+w.h);
  return (cx-nx)**2+(cy-ny)**2 < r*r;
}
function rectsOverlap(a,b){
  return !(a.x+a.w<=b.x||a.x>=b.x+b.w||a.y+a.h<=b.y||a.y>=b.y+b.h);
}

/* ================= EFFECTS ================= */
function spawnExplosion(x,y,color){
  effects.push({x,y,r:10,t:0,color});
}
function updateEffects(dt){
  for(let i=effects.length-1;i>=0;i--){
    const e=effects[i];
    e.t+=dt; e.r+=260*dt;
    if(e.t>0.6) effects.splice(i,1);
  }
}
function drawEffects(){
  for(const e of effects){
    const a=1-e.t/0.6;
    ctx.save();
    ctx.globalCompositeOperation="lighter";
    ctx.shadowColor=e.color;
    ctx.shadowBlur=40;
    ctx.strokeStyle=`rgba(${e.color},${a})`;
    ctx.lineWidth=2;
    ctx.beginPath();
    ctx.arc(e.x,e.y,e.r,0,Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}

/* ================= DRAW HELPERS ================= */
function neonRect(x,y,w,h,c){
  ctx.save();
  ctx.shadowColor=c;
  ctx.shadowBlur=18;
  ctx.strokeStyle=c;
  ctx.lineWidth=2;
  ctx.strokeRect(x,y,w,h);
  ctx.restore();
}

/* ================= ROBOT DRAWING ================= */
function drawEnemy(e){
  const s=e.r*2;
  const pulse=1+Math.sin(now()*4+e.x)*0.06;

  ctx.save();
  ctx.translate(e.x,e.y);
  ctx.scale(pulse,pulse);

  ctx.shadowColor="rgba(255,0,255,.9)";
  ctx.shadowBlur=22;
  ctx.strokeStyle="rgba(255,80,255,.95)";
  ctx.lineWidth=2;
  ctx.strokeRect(-s/2,-s/2,s,s);

  ctx.beginPath();
  ctx.moveTo(-s/2,-s/4); ctx.lineTo(-s/4,-s/2);
  ctx.moveTo(s/2,-s/4);  ctx.lineTo(s/4,-s/2);
  ctx.moveTo(-s/2,s/4);  ctx.lineTo(-s/4,s/2);
  ctx.moveTo(s/2,s/4);   ctx.lineTo(s/4,s/2);
  ctx.stroke();

  ctx.shadowBlur=12;
  ctx.strokeStyle="rgba(255,180,255,.9)";
  ctx.strokeRect(-s/4,-s/4,s/2,s/2);

  ctx.shadowBlur=18;
  ctx.strokeStyle="rgba(255,0,120,1)";
  ctx.beginPath();
  ctx.moveTo(-s/6,0); ctx.lineTo(s/6,0);
  ctx.stroke();

  ctx.restore();
}

function drawPlayer(player){
  const ang=Math.atan2(player.fy,player.fx);
  ctx.save();
  ctx.translate(player.x,player.y);
  ctx.rotate(ang);

  ctx.shadowColor="rgba(0,255,255,1)";
  ctx.shadowBlur=26;
  ctx.strokeStyle="rgba(120,255,255,.95)";
  ctx.lineWidth=2;

  ctx.beginPath();
  ctx.moveTo(14,0);
  ctx.lineTo(-10,-10);
  ctx.lineTo(-14,-6);
  ctx.lineTo(-14,6);
  ctx.lineTo(-10,10);
  ctx.closePath();
  ctx.stroke();

  ctx.beginPath();
  ctx.moveTo(14,0); ctx.lineTo(22,0);
  ctx.stroke();

  ctx.shadowBlur=12;
  ctx.beginPath();
  ctx.moveTo(-6,-12); ctx.lineTo(-2,-12);
  ctx.moveTo(-6,12);  ctx.lineTo(-2,12);
  ctx.stroke();

  ctx.shadowBlur=18;
  ctx.strokeStyle="rgba(180,255,255,1)";
  ctx.strokeRect(-6,-4,8,8);

  ctx.restore();
}

/* ================= WALLS ================= */
function buildBorderWalls(exitsOpen){
  const w=[],mx=ROOM_W/2,my=ROOM_H/2,g=exitsOpen?GAP:0;
  const wall=(x,y,wid,hei)=>w.push({x,y,w:wid,h:hei});

  if(!exitsOpen) wall(0,0,ROOM_W,WALL);
  else{ wall(0,0,mx-g/2,WALL); wall(mx+g/2,0,mx-g/2,WALL); }

  if(!exitsOpen) wall(0,ROOM_H-WALL,ROOM_W,WALL);
  else{ wall(0,ROOM_H-WALL,mx-g/2,WALL); wall(mx+g/2,ROOM_H-WALL,mx-g/2,WALL); }

  if(!exitsOpen) wall(0,0,WALL,ROOM_H);
  else{ wall(0,0,WALL,my-g/2); wall(0,my+g/2,WALL,my-g/2); }

  if(!exitsOpen) wall(ROOM_W-WALL,0,WALL,ROOM_H);
  else{ wall(ROOM_W-WALL,0,WALL,my-g/2); wall(ROOM_W-WALL,my+g/2,WALL,my-g/2); }

  return w;
}

/* === overlap-safe inner walls: checks against borderWalls + existing inner === */
function generateInnerWalls(blockers){
  const w=[];
  const shapes=4+Math.floor(Math.random()*3);
  let placed=0, tries=0;

  while(placed<shapes && tries++<220){
    const gx=Math.floor(rand(2,8))*GRID;
    const gy=Math.floor(rand(2,6))*GRID;
    const t=Math.floor(Math.random()*4), p=[];

    if(t===0)p.push({x:gx,y:gy,w:WALL,h:GRID*2});
    if(t===1)p.push({x:gx,y:gy,w:GRID*2,h:WALL});
    if(t===2){p.push({x:gx,y:gy,w:WALL,h:GRID*2});p.push({x:gx,y:gy+GRID*2,w:GRID*2,h:WALL});}
    if(t===3)p.push({x:gx,y:gy,w:GRID,h:GRID});

    const ok = p.every(a =>
      !w.some(b=>rectsOverlap(a,b)) &&
      !blockers.some(b=>rectsOverlap(a,b))
    );

    if(ok){
      w.push(...p);
      placed++;
    }
  }
  return w;
}

/* ================= ROOM ================= */
function makeRoom(){
  const borderWalls=buildBorderWalls(false);
  const innerWalls=generateInnerWalls(borderWalls);

  let spawn;
  do{
    spawn={x:rand(80,ROOM_W-80),y:rand(80,ROOM_H-80)};
  }while([...innerWalls,...borderWalls].some(w=>circleRect(spawn.x,spawn.y,R,w)));

  const enemies=[];
  for(let i=0;i<6;i++){
    let e;
    do{
      e={x:rand(80,ROOM_W-80),y:rand(80,ROOM_H-80)};
    }while([...innerWalls,...borderWalls].some(w=>circleRect(e.x,e.y,R,w))||
            Math.hypot(e.x-spawn.x,e.y-spawn.y)<140);
    enemies.push({...e,r:R,vx:0,vy:0,dirT:0,shootT:rand(1,2.5),alive:true,active:false});
  }
  return{innerWalls,borderWalls,enemies,playerSpawn:spawn,exitsOpen:false};
}

/* ================= STATE ================= */
let room=makeRoom();
let player={...room.playerSpawn,r:R,fx:1,fy:0};
let bullets=[],enemiesActivated=false,roomCount=1;

function restartGame(){
  lives=3;
  gameOver=false;
  hideMessage();
  room=makeRoom();
  player={...room.playerSpawn,r:R,fx:1,fy:0};
  bullets=[];
  enemiesActivated=false;
  roomCount=1;
}

/* ================= MOVE ================= */
function move(ent,dt){
  let nx=ent.x+ent.vx*dt,ny=ent.y+ent.vy*dt;
  for(const w of [...room.innerWalls,...room.borderWalls]){
    if(circleRect(nx,ent.y,ent.r,w))nx=ent.x;
    if(circleRect(ent.x,ny,ent.r,w))ny=ent.y;
  }
  ent.x=nx; ent.y=ny;
}

/* ================= LOOP ================= */
let last=now();
function loop(){
  const t=now(),dt=Math.min(.03,t-last); last=t;

  if(gameOver){ requestAnimationFrame(loop); return; }

  let ax=0,ay=0;
  if(keys.has("ArrowLeft")||keys.has("KeyA"))ax--;
  if(keys.has("ArrowRight")||keys.has("KeyD"))ax++;
  if(keys.has("ArrowUp")||keys.has("KeyW"))ay--;
  if(keys.has("ArrowDown")||keys.has("KeyS"))ay++;

  if((ax||ay) && !enemiesActivated){
    enemiesActivated=true;
    room.enemies.forEach(e=>e.active=true);
  }

  if(ax||ay){
    const m=Math.hypot(ax,ay);
    player.fx=ax/m; player.fy=ay/m;
  }
  player.vx=ax*PLAYER_SPEED; player.vy=ay*PLAYER_SPEED;
  move(player,dt);

  if(keys.has("Space")&&!player.cool){
    bullets.push({x:player.x,y:player.y,vx:player.fx*BULLET_SPEED,vy:player.fy*BULLET_SPEED,r:4,life:1,friendly:true});
    player.cool=.18;
  }
  player.cool=Math.max(0,(player.cool||0)-dt);

  /* ===== enemies move + shoot (RESTORED) ===== */
  for(const e of room.enemies){
    if(!e.alive||!e.active)continue;

    e.dirT-=dt;
    if(e.dirT<=0){
      e.dirT=1.6;
      const dx=player.x-e.x,dy=player.y-e.y;
      if(Math.abs(dx)>Math.abs(dy)){e.vx=Math.sign(dx)*ENEMY_SPEED;e.vy=0;}
      else{e.vx=0;e.vy=Math.sign(dy)*ENEMY_SPEED;}
    }
    move(e,dt);

    e.shootT-=dt;
    if(e.shootT<=0&&Math.random()<0.5){
      e.shootT=rand(1.5,3);
      const dx=player.x-e.x,dy=player.y-e.y,m=Math.hypot(dx,dy)||1;
      bullets.push({x:e.x,y:e.y,vx:dx/m*ENEMY_BULLET_SPEED,vy:dy/m*ENEMY_BULLET_SPEED,r:4,life:1,friendly:false});
    }
  }

  for(let i=bullets.length-1;i>=0;i--){
    const b=bullets[i];
    b.x+=b.vx*dt; b.y+=b.vy*dt; b.life-=dt;

    // bounce on walls
    for(const w of [...room.innerWalls,...room.borderWalls]){
      if(circleRect(b.x,b.y,b.r,w)){ b.vx*=-1; b.vy*=-1; break; }
    }

    // enemy bullet hits player
    if(!b.friendly && Math.hypot(b.x-player.x,b.y-player.y)<b.r+player.r){
      spawnExplosion(player.x,player.y,"0,255,255");
      bullets.splice(i,1);
      lives--;
      if(lives<=0){
        gameOver=true;
        showMessage("GAME OVER<br><span style='font-size:18px'>PRESS ANY KEY</span>");
      }else{
        player={...room.playerSpawn,r:R,fx:1,fy:0};
      }
      break;
    }

    // player bullet hits enemy
    if(b.friendly){
      for(const e of room.enemies){
        if(e.alive && Math.hypot(b.x-e.x,b.y-e.y)<b.r+e.r){
          spawnExplosion(e.x,e.y,"255,0,255");
          e.alive=false;
          bullets.splice(i,1);
          break;
        }
      }
    }

    if(b.life<=0) bullets.splice(i,1);
  }

  updateEffects(dt);

  // exits open when all enemies dead
  if(!room.exitsOpen && room.enemies.every(e=>!e.alive)){
    room.exitsOpen=true;
    room.borderWalls=buildBorderWalls(true);
  }

  // leave room through gap -> new room
  if(room.exitsOpen && (player.x<0||player.x>ROOM_W||player.y<0||player.y>ROOM_H)){
    room=makeRoom();
    player={...room.playerSpawn,r:R,fx:1,fy:0};
    bullets=[]; enemiesActivated=false; roomCount++;
  }

  /* ===== render ===== */
  ctx.fillStyle="#03040c";
  ctx.fillRect(0,0,canvas.width,canvas.height);

  const s=Math.min(innerWidth/ROOM_W,innerHeight/ROOM_H);
  const ox=(innerWidth-ROOM_W*s)/2,oy=(innerHeight-ROOM_H*s)/2;
  ctx.save(); ctx.translate(ox,oy); ctx.scale(s,s);

  for(const w of [...room.innerWalls,...room.borderWalls]) neonRect(w.x,w.y,w.w,w.h,"rgba(0,255,255,.7)");
  for(const e of room.enemies) if(e.alive) drawEnemy(e);
  drawPlayer(player);
  for(const b of bullets)
    neonRect(b.x-b.r,b.y-b.r,b.r*2,b.r*2,b.friendly?"rgba(200,255,255,.9)":"rgba(255,80,200,.9)");
  drawEffects();

  ctx.restore();
  document.getElementById("hud").textContent=`ROOM ${roomCount} | LIVES ${lives}`;

  requestAnimationFrame(loop);
}
loop();

})();
</script>
</body>
</html>

