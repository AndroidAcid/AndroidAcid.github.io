<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Classic Tetris (Eye-Safe)</title>
  <style>
    :root{
      --bg: #f2f2f2;
      --panel: #ffffff;
      --border: #d0d0d0;
      --grid: #e6e6e6;
      --text: #1f1f1f;
      --muted: #5a5a5a;
      --shadow: rgba(0,0,0,.08);
    }
    html,body{height:100%;}
    body{
      margin:0;
      background: var(--bg);
      color: var(--text);
      font: 14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    /* Your request: instructions text is BLACK in dark mode */
    body.dark-mode .warn { color: #000000; }

    .wrap{
      display:grid;
      grid-template-columns: auto 220px;
      gap:16px;
      padding:16px;
    }
    .card{
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 12px;
      box-shadow: 0 6px 18px var(--shadow);
      padding: 12px;
    }
    canvas{
      display:block;
      border-radius: 10px;
      background: #fafafa;
      border: 1px solid var(--border);
    }
    h1{
      font-size: 16px;
      margin: 0 0 10px;
      font-weight: 650;
    }
    .stat{
      display:flex; justify-content:space-between;
      padding:6px 0; border-bottom: 1px solid #eeeeee;
    }
    .stat:last-child{border-bottom:none;}
    .label{color: var(--muted);}
    .kbd{
      display:inline-block;
      padding:2px 6px;
      border:1px solid var(--border);
      border-bottom-color:#bdbdbd;
      border-radius:6px;
      background:#f8f8f8;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size: 12px;
    }
    .small{font-size:12px;color:var(--muted);}
    .row{display:flex; gap:10px;}
    .mini canvas{background:#fbfbfb;}
    button{
      width:100%;
      padding:10px 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#f7f7f7;
      cursor:pointer;
      font-weight:600;
    }
    button:hover{background:#f2f2f2;}
    .warn{
      margin-top:10px;
      padding:10px;
      border-radius:10px;
      background:#f6f6f6;
      border:1px solid #e2e2e2;
      color:#3a3a3a;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <canvas id="game" width="320" height="640" aria-label="Tetris board"></canvas>
    </div>

    <div class="card">
      <h1>Classic Tetris</h1>

      <div class="row mini">
        <div style="flex:1">
          <div class="small" style="margin-bottom:6px;">NEXT</div>
          <canvas id="next" width="96" height="160"></canvas>
        </div>
        <div style="flex:1">
          <div class="small" style="margin-bottom:6px;">HOLD</div>
          <canvas id="hold" width="96" height="96"></canvas>
        </div>
      </div>

      <div style="height:10px"></div>

      <div class="stat"><span class="label">Score</span><span id="score">0</span></div>
      <div class="stat"><span class="label">Level</span><span id="level">1</span></div>
      <div class="stat"><span class="label">Lines</span><span id="lines">0</span></div>

      <div style="height:12px"></div>
      <button id="restart">Restart (R)</button>

      <div class="warn small">
        Controls:
        <span class="kbd">←</span>/<span class="kbd">→</span> move,
        <span class="kbd">↓</span> soft drop,
        <span class="kbd">↑</span> rotate,
        <span class="kbd">Space</span> hard drop,
        <span class="kbd">C</span> hold,
        <span class="kbd">P</span> pause,
        <span class="kbd">D</span> dark mode,
        <span class="kbd">R</span> restart.
      </div>

      <div class="small" style="margin-top:10px;">
        No flashing, no neon, no effects. Just blocks doing block things.
      </div>
    </div>
  </div>

<script>
(() => {
  // Two gentle palettes (muted, non-neon)
  const PALETTES = {
    light: {
      I: "#4aa3b5",
      O: "#c9b458",
      T: "#8a6fb3",
      S: "#6fb37a",
      Z: "#b56a6a",
      J: "#5f7fb3",
      L: "#b3875f",
      GHOST: "rgba(120,120,120,0.18)",
      GRID: "#e6e6e6",
      OUTLINE: "rgba(0,0,0,0.14)",
      TEXT: "#1f1f1f",
      BG: "#fafafa",
      PAGE_BG: "#f2f2f2",
      PANEL: "#ffffff",
      BORDER: "#d0d0d0",
      BUTTON: "#f7f7f7",
      BUTTON_HOVER: "#f2f2f2",
      WARN_BG: "#f6f6f6",
      WARN_BORDER: "#e2e2e2",
      MUTED: "#5a5a5a"
    },
    dark: {
      I: "#5fb3c3",
      O: "#d1c07a",
      T: "#9a84c2",
      S: "#7fc28c",
      Z: "#c07a7a",
      J: "#7a95c0",
      L: "#c09a7a",
      GHOST: "rgba(200,200,200,0.14)",
      GRID: "#2a2a2a",
      OUTLINE: "rgba(255,255,255,0.18)",
      TEXT: "#e6e6e6",
      BG: "#151515",
      PAGE_BG: "#101010",
      PANEL: "#1a1a1a",
      BORDER: "#2a2a2a",
      BUTTON: "#1f1f1f",
      BUTTON_HOVER: "#232323",
      WARN_BG: "#171717",
      WARN_BORDER: "#2a2a2a",
      MUTED: "#b7b7b7"
    }
  };

  let darkMode = false;
  let COLORS = PALETTES.light;

  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d", { alpha: false });
  const nextCanvas = document.getElementById("next");
  const nextCtx = nextCanvas.getContext("2d", { alpha: false });
  const holdCanvas = document.getElementById("hold");
  const holdCtx = holdCanvas.getContext("2d", { alpha: false });

  const UI = {
    score: document.getElementById("score"),
    level: document.getElementById("level"),
    lines: document.getElementById("lines"),
    restart: document.getElementById("restart"),
  };

  // Board
  const W = 10, H = 20;
  const BLOCK = 32;

  // Tetromino definitions in 4x4
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
  };

  const TYPES = ["I","O","T","S","Z","J","L"];

  // SRS kick tables (JLSTZ share, I has its own)
  const KICKS_JLSTZ = {
    "0>1": [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    "1>0": [[0,0],[1,0],[1,-1],[0,2],[1,2]],
    "1>2": [[0,0],[1,0],[1,-1],[0,2],[1,2]],
    "2>1": [[0,0],[-1,0],[-1,1],[0,-2],[-1,-2]],
    "2>3": [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
    "3>2": [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    "3>0": [[0,0],[-1,0],[-1,-1],[0,2],[-1,2]],
    "0>3": [[0,0],[1,0],[1,1],[0,-2],[1,-2]],
  };

  const KICKS_I = {
    "0>1": [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    "1>0": [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    "1>2": [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
    "2>1": [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    "2>3": [[0,0],[2,0],[-1,0],[2,1],[-1,-2]],
    "3>2": [[0,0],[-2,0],[1,0],[-2,-1],[1,2]],
    "3>0": [[0,0],[1,0],[-2,0],[1,-2],[-2,1]],
    "0>3": [[0,0],[-1,0],[2,0],[-1,2],[2,-1]],
  };

  function makeMatrix(w, h, fill = 0){
    return Array.from({length:h}, () => Array(w).fill(fill));
  }
  function clone4(m){ return m.map(r => r.slice()); }

  function rotateCW(mat){
    const n = mat.length;
    const out = makeMatrix(n,n,0);
    for(let y=0;y<n;y++) for(let x=0;x<n;x++) out[x][n-1-y]=mat[y][x];
    return out;
  }
  function rotateCCW(mat){
    const n = mat.length;
    const out = makeMatrix(n,n,0);
    for(let y=0;y<n;y++) for(let x=0;x<n;x++) out[n-1-x][y]=mat[y][x];
    return out;
  }

  // 7-bag randomizer
  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j = (Math.random()*(i+1))|0;
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }
  class Bag {
    constructor(){ this.q = []; }
    next(){
      if(this.q.length === 0) this.q = shuffle(TYPES.slice());
      return this.q.pop();
    }
  }

  const state = {
    board: makeMatrix(W,H,0),
    bag: new Bag(),
    queue: [],
    piece: null,
    hold: null,
    holdLocked: false,
    score: 0,
    level: 1,
    lines: 0,
    paused: false,
    gameOver: false,
    dropCounter: 0,
    dropInterval: 800,
    lastTime: 0,
  };

  function applyTheme(){
    const root = document.documentElement;
    root.style.setProperty("--bg", COLORS.PAGE_BG);
    root.style.setProperty("--panel", COLORS.PANEL);
    root.style.setProperty("--border", COLORS.BORDER);
    root.style.setProperty("--text", COLORS.TEXT);
    root.style.setProperty("--muted", COLORS.MUTED);

    document.querySelectorAll("button").forEach(b => {
      b.style.background = COLORS.BUTTON;
      b.style.borderColor = COLORS.BORDER;
      b.style.color = COLORS.TEXT;
      b.onmouseenter = () => b.style.background = COLORS.BUTTON_HOVER;
      b.onmouseleave = () => b.style.background = COLORS.BUTTON;
    });
    document.querySelectorAll(".warn").forEach(w => {
      w.style.background = COLORS.WARN_BG;
      w.style.borderColor = COLORS.WARN_BORDER;
      // NOTE: text color for .warn in dark mode is forced by CSS (black) per your request
    });
    document.querySelectorAll("canvas").forEach(c => {
      c.style.borderColor = COLORS.BORDER;
    });
  }

  function toggleDarkMode(){
    darkMode = !darkMode;
    COLORS = darkMode ? PALETTES.dark : PALETTES.light;
    document.body.classList.toggle("dark-mode", darkMode);
    applyTheme();
  }

  function refillQueue(){
    while(state.queue.length < 5) state.queue.push(state.bag.next());
  }

  function collides(p, dx, dy, mat){
    for(let y=0;y<4;y++){
      for(let x=0;x<4;x++){
        if(!mat[y][x]) continue;
        const nx = p.x + x + dx;
        const ny = p.y + y + dy;
        if(nx < 0 || nx >= W || ny >= H) return true;
        if(ny >= 0 && state.board[ny][nx]) return true;
      }
    }
    return false;
  }

  function spawnPiece(type){
    const shape = clone4(SHAPES[type]);
    const p = { type, mat: shape, x: 3, y: -1, rot: 0 };
    if(type === "I"){ p.x = 3; p.y = -2; }
    if(collides(p, 0, 0, p.mat)) state.gameOver = true;
    return p;
  }

  function newTurn(){
    state.holdLocked = false;
    refillQueue();
    const t = state.queue.shift();
    state.piece = spawnPiece(t);
    refillQueue();
  }

  function mergePiece(){
    const p = state.piece;
    for(let y=0;y<4;y++){
      for(let x=0;x<4;x++){
        if(!p.mat[y][x]) continue;
        const by = p.y + y;
        const bx = p.x + x;
        if(by >= 0 && by < H && bx >= 0 && bx < W){
          state.board[by][bx] = p.type;
        }
      }
    }
  }

  function clearLines(){
    let cleared = 0;
    for(let y=H-1;y>=0;y--){
      if(state.board[y].every(v => v)){
        state.board.splice(y,1);
        state.board.unshift(Array(W).fill(0));
        cleared++;
        y++;
      }
    }
    if(cleared > 0){
      state.lines += cleared;
      // 1=100,2=300,3=500,4=800 * level
      const table = [0,100,300,500,800];
      state.score += (table[cleared] || 0) * state.level;

      const newLevel = Math.floor(state.lines / 10) + 1;
      if(newLevel !== state.level){
        state.level = newLevel;
        state.dropInterval = Math.max(120, 800 - (state.level-1)*55);
      }
    }
  }

  function lockPiece(){
    mergePiece();
    clearLines();
    newTurn();
  }

  function hardDrop(){
    if(state.paused || state.gameOver) return;
    let d = 0;
    while(!collides(state.piece,0,1,state.piece.mat)){
      state.piece.y++;
      d++;
    }
    state.score += d * 2;
    lockPiece();
  }

  function softDrop(){
    if(state.paused || state.gameOver) return;
    if(!collides(state.piece,0,1,state.piece.mat)){
      state.piece.y++;
      state.score += 1;
    } else {
      lockPiece();
    }
  }

  function move(dx){
    if(state.paused || state.gameOver) return;
    if(!collides(state.piece,dx,0,state.piece.mat)) state.piece.x += dx;
  }

  function rotate(dir){ // +1 CW, -1 CCW
    if(state.paused || state.gameOver) return;
    const p = state.piece;
    const from = p.rot;
    const to = (p.rot + (dir===1?1:3)) % 4;
    const rotated = (dir===1) ? rotateCW(p.mat) : rotateCCW(p.mat);

    // O: simple rotate if possible
    if(p.type === "O"){
      if(!collides(p,0,0,rotated)){
        p.mat = rotated; p.rot = to;
      }
      return;
    }

    const key = `${from}>${to}`;
    const kicks = (p.type === "I") ? (KICKS_I[key] || [[0,0]]) : (KICKS_JLSTZ[key] || [[0,0]]);

    for(const [kx,ky] of kicks){
      if(!collides(p,kx,ky,rotated)){
        p.x += kx;
        p.y += ky;
        p.mat = rotated;
        p.rot = to;
        return;
      }
    }
  }

  function hold(){
    if(state.paused || state.gameOver) return;
    if(state.holdLocked) return;
    state.holdLocked = true;

    const cur = state.piece.type;
    if(state.hold){
      const swap = state.hold;
      state.hold = cur;
      state.piece = spawnPiece(swap);
    } else {
      state.hold = cur;
      newTurn();
    }
  }

  function reset(){
    state.board = makeMatrix(W,H,0);
    state.bag = new Bag();
    state.queue = [];
    state.piece = null;
    state.hold = null;
    state.holdLocked = false;
    state.score = 0;
    state.level = 1;
    state.lines = 0;
    state.paused = false;
    state.gameOver = false;
    state.dropCounter = 0;
    state.dropInterval = 800;
    state.lastTime = 0;

    refillQueue();
    newTurn();
    updateUI();
  }

  // Drawing
  function drawCell(ctx2, x, y, color, size){
    const px = x*size, py = y*size;
    ctx2.fillStyle = color;
    ctx2.fillRect(px, py, size, size);
    ctx2.strokeStyle = COLORS.OUTLINE;
    ctx2.lineWidth = 1;
    ctx2.strokeRect(px+0.5, py+0.5, size-1, size-1);
  }

  function drawGrid(ctx2, w, h, size){
    ctx2.strokeStyle = COLORS.GRID;
    ctx2.lineWidth = 1;
    for(let x=0;x<=w;x++){
      ctx2.beginPath();
      ctx2.moveTo(x*size+0.5, 0);
      ctx2.lineTo(x*size+0.5, h*size);
      ctx2.stroke();
    }
    for(let y=0;y<=h;y++){
      ctx2.beginPath();
      ctx2.moveTo(0, y*size+0.5);
      ctx2.lineTo(w*size, y*size+0.5);
      ctx2.stroke();
    }
  }

  function overlayText(text){
    ctx.save();
    ctx.fillStyle = darkMode ? "rgba(20,20,20,0.92)" : "rgba(245,245,245,0.92)";
    ctx.fillRect(0, canvas.height/2 - 44, canvas.width, 88);
    ctx.strokeStyle = COLORS.OUTLINE;
    ctx.strokeRect(0.5, canvas.height/2 - 43.5, canvas.width-1, 87);
    ctx.fillStyle = COLORS.TEXT;
    ctx.font = "700 26px system-ui, -apple-system, Segoe UI, Roboto, Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(text, canvas.width/2, canvas.height/2);
    ctx.restore();
  }

  function drawBoard(){
    ctx.fillStyle = COLORS.BG;
    ctx.fillRect(0,0,canvas.width,canvas.height);

    drawGrid(ctx, W, H, BLOCK);

    for(let y=0;y<H;y++){
      for(let x=0;x<W;x++){
        const t = state.board[y][x];
        if(t) drawCell(ctx, x, y, COLORS[t], BLOCK);
      }
    }

    if(state.piece && !state.gameOver){
      // ghost
      const ghost = {...state.piece, x: state.piece.x, y: state.piece.y, mat: state.piece.mat};
      while(!collides(ghost,0,1,ghost.mat)) ghost.y++;

      for(let y=0;y<4;y++){
        for(let x=0;x<4;x++){
          if(!ghost.mat[y][x]) continue;
          const gx = ghost.x + x;
          const gy = ghost.y + y;
          if(gy >= 0 && gy < H && gx >= 0 && gx < W){
            drawCell(ctx, gx, gy, COLORS.GHOST, BLOCK);
          }
        }
      }

      // active
      const p = state.piece;
      for(let y=0;y<4;y++){
        for(let x=0;x<4;x++){
          if(!p.mat[y][x]) continue;
          const bx = p.x + x;
          const by = p.y + y;
          if(by >= 0 && by < H && bx >= 0 && bx < W){
            drawCell(ctx, bx, by, COLORS[p.type], BLOCK);
          }
        }
      }
    }

    if(state.paused && !state.gameOver) overlayText("Paused");
    if(state.gameOver) overlayText("Game Over");
  }

  function drawMini(ctx2, pieceType, cellSize, wCells, hCells){
    ctx2.fillStyle = darkMode ? "#111111" : "#fbfbfb";
    ctx2.fillRect(0,0,ctx2.canvas.width,ctx2.canvas.height);
    ctx2.strokeStyle = COLORS.OUTLINE;
    ctx2.strokeRect(0.5,0.5,ctx2.canvas.width-1,ctx2.canvas.height-1);

    if(!pieceType) return;
    const mat = SHAPES[pieceType];
    const ox = Math.floor((wCells - 4)/2);
    const oy = Math.floor((hCells - 4)/2);

    for(let y=0;y<4;y++){
      for(let x=0;x<4;x++){
        if(!mat[y][x]) continue;
        const px = (x+ox)*cellSize;
        const py = (y+oy)*cellSize;
        ctx2.fillStyle = COLORS[pieceType];
        ctx2.fillRect(px, py, cellSize, cellSize);
        ctx2.strokeStyle = COLORS.OUTLINE;
        ctx2.strokeRect(px+0.5, py+0.5, cellSize-1, cellSize-1);
      }
    }
  }

  function drawNext(){
    nextCtx.fillStyle = darkMode ? "#111111" : "#fbfbfb";
    nextCtx.fillRect(0,0,nextCanvas.width,nextCanvas.height);
    nextCtx.strokeStyle = COLORS.OUTLINE;
    nextCtx.strokeRect(0.5,0.5,nextCanvas.width-1,nextCanvas.height-1);

    const cell = 16;
    const slotH = 32;
    for(let i=0;i<5;i++){
      const t = state.queue[i];
      if(!t) continue;
      const mat = SHAPES[t];

      const baseY = i*slotH;
      const ox = 1;
      const oy = Math.floor((slotH/cell - 4)/2);

      for(let y=0;y<4;y++){
        for(let x=0;x<4;x++){
          if(!mat[y][x]) continue;
          const px = (x+ox)*cell;
          const py = baseY + (y+oy)*cell;
          nextCtx.fillStyle = COLORS[t];
          nextCtx.fillRect(px, py, cell, cell);
          nextCtx.strokeStyle = COLORS.OUTLINE;
          nextCtx.strokeRect(px+0.5, py+0.5, cell-1, cell-1);
        }
      }
    }
  }

  function drawHold(){
    drawMini(holdCtx, state.hold, 20, 4, 4);
    if(state.holdLocked && !state.gameOver){
      holdCtx.fillStyle = darkMode ? "rgba(255,255,255,0.06)" : "rgba(0,0,0,0.05)";
      holdCtx.fillRect(0,0,holdCanvas.width,holdCanvas.height);
    }
  }

  function updateUI(){
    UI.score.textContent = String(state.score);
    UI.level.textContent = String(state.level);
    UI.lines.textContent = String(state.lines);
  }

  function update(time = 0){
    const delta = time - state.lastTime;
    state.lastTime = time;

    if(!state.paused && !state.gameOver){
      state.dropCounter += delta;
      if(state.dropCounter >= state.dropInterval){
        state.dropCounter = 0;
        if(!collides(state.piece,0,1,state.piece.mat)){
          state.piece.y++;
        } else {
          lockPiece();
        }
      }
    }

    drawBoard();
    drawNext();
    drawHold();
    updateUI();
    requestAnimationFrame(update);
  }

  // Input (Z/X removed entirely; Up rotates)
  window.addEventListener("keydown", (e) => {
    if(["ArrowLeft","ArrowRight","ArrowDown","ArrowUp","Space"].includes(e.code)) e.preventDefault();
    if(e.repeat) return;

    // Global toggles (work even when paused/game over)
    if(e.code === "KeyD"){ toggleDarkMode(); return; }
    if(e.code === "KeyP"){ state.paused = !state.paused; return; }
    if(e.code === "KeyR"){ reset(); return; }

    // Quick restart if game over
    if(state.gameOver){
      if(e.code === "Enter" || e.code === "Space") reset();
      return;
    }

    switch(e.code){
      case "ArrowLeft": move(-1); break;
      case "ArrowRight": move(1); break;
      case "ArrowDown": softDrop(); state.dropCounter = 0; break;
      case "ArrowUp": rotate(1); break;               // rotate clockwise
      case "Space": hardDrop(); state.dropCounter = 0; break;
      case "KeyC": hold(); break;
    }
  });

  UI.restart.addEventListener("click", reset);

  // Start
  applyTheme();
  reset();
  requestAnimationFrame(update);
})();
</script>
</body>
</html>

